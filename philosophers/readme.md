어떻게 만들 것인가?
​
1. 메인 스레드는 모니터링을 실시하고 기타 스레드는 개별 철학자로 분류한다
​
2. 메인 스레드 작동 방식  
	2-1. 프로그램 실행 시, 들어온 인자를 검사  
	2-2. 인자 이상 없을 시, mutex(fork, print, start) 및 메인 구조체와 철학자 구조체를 초기화  
	2-3. 초기화에서 문제가 없으면, 철학자 스레드를 만든다. 철학자 스레드는 동시 실행을 위해 만드는 동안 start mutex를 통해 철학자 스레드 함수가 도는 걸 막는다  
	2-4. 철학자 스레드 분류를 마치고 나서 메인 스레드에서 개별 철학자의 죽음 및 만찬회 전체 식사 횟수를 만족하는 지 지속적으로 검사한다  
	2-5. 죽음 또는 식사 횟수 만족 시, stop 플래그를 통해 개별 철학자들 전부 식사회를 끝낸다  
	2-6. 모든 철학자 스레드가 활동을 끝내면 구조체에서 뮤텍스 및 malloc 한 자료들을 free한다  
	2-7. 종료  

3. 철학자 스레드 작동 방식  
	3-1. 중앙  
		3-1-가. 모든 철학자 스레드의 생성이 끝나면, start 뮤텍스 잠금을 풀고 실행한다.  
		3-2-나. 각 철학자의 자원 다툼을 원활하게 하기 위해 홀, 짝 철학자의 시작을 부분적으로 늦춘다   
		3-3-다. 각 phase(take_fork, eating, release_fork, sleeping, thinking)를 돌아가면서 반복 실행한다   
		3-3-라. 메인 스레드에서 stop 플래그가 등록되는 게 확인 되면, 각 phase에서 종료 값을 반환 받아서 스레드를 종료한다   
	3-2. take_fork   
		3-2-가. chk_over 함수를 통해 수명 초과 또는 식사회 종료 여부를 확인한다.   
		3-2-나. 포크는 홀수 철학자는 왼->오, 짝수 철학자는 오->왼 순으로 잡는다.   
		3-2-다. 어떠한 연유로 식사회를 끝내야 하면, 굳이 포크를 쥘 필요가 없다. 이 때, 종료 여부를 확인할 stop 	flag는 공유자원이기에 print mutex를 통해 보호한 상태에서 확인한다.   
		3-2-라. 각 포크 뮤텍스(포크 그 자체)를 통해 제대로 잠길 경우, 포크를 취득했으므로 포크를 취득했다는 내용을 출력한다
		3-2-마. 3-2-가 ~ 라 내용을 포크 2개를 쥘 때까지 반복한다
	3-3. eating
		3-3-가. chk_over 확인  
		3-3-나. eating 출력 후, 철학자가 시행한 식사 횟수와 마지막 식사 시간을  등록한다. 이는, 메인 스레드가 참고하는 공유 자원이므로 print_mutex를 통해 잠금하고 안전하게 변환  
		3-3-다. wait_time을 통해 식사 시간 동안 유휴 상태로 둔다. 만약, stop flag가  활성화 되어 있는 경우 대기 없이 빠져나온다  
		3-3-라. wait_time 이후, chk_over 판정을 통해 stop flag 활성화 또는 수명 초과 여부를 판단한다
	3-4. sleeping
		3-4-가. sleeping 출력
		3-4-나 ~ 다. eating 3-3-다 ~ 라 phase와 동일
	3-5. thinking
		3-5-가. thinking 출력
		3-5-나. 다른 철학자가 포크를 잡을 수 있도록 안배하기 위해 usleep을 건다
​
4. struct  
	4-1. philo  
		4-1-가. name : 철학자(스레드) 생성 시, pthread 라이브러리에서 각 스레드를  구별할 id  
		4-1-나. name_num : 각 phase 출력 및 모니터링을 위해 사용할 id  
		4-1-다. l_fork : 철학자(스레드) 왼쪽에 위치한 포크  
		4-1-라. r_fork : 철학자(스레드) 오른쪽에 위치한 포크  
		4-1-마. *connect : 공유자원에 접근하기 위한 구조체 포인터  
	4-2. flag  
		4-2-가. philo_num : 만들어야할 철학자(스레드) 개수  
		4-2-나. lifespan : 철학자(스레드) 수명  
		4-2-다. time_eat : 철학자(스레드)가 한 번 식사하는 데 소요되는 시간  
		4-2-라. time_sleep : 철학자(스레드)가 한 번 자는 데 소요되는 시간  
		4-2-마. must_eat : 식사회가 종료되는 데 필요한 각 철학자의 식사 횟수(select  option)  
		4-2-바. stop(공유자원) : 각 철학자에게 식사회 종료 알림을 위한 플래그  
		4-2-사. init : 식사회 시작 시간  
		4-2-아. print : 각 철학자들의 phase 진입 및, 출력 시 각 phase에 대한   timestamp의 순차적 출력이 보장되기 위한 mutex  
		4-2-자. start : 각 철학자들이 모두 자리에 착석했는지 알기 위한 mutex. 착석이 되었으면 unlock하여 thread가 돌아가기 시작한다  
		4-2-차. *fork : 각 fork_state를 보호하기 위한 mutex. lock이면 쥐었음을 뜻하며 unlock은 놓았음을 뜻한다  
					즉, 포크 그 자체이기도 하다. 
​
5. header
	5-1. pthread.h : 운영체제 간 호환을 염두해 둔 POSIX 규격의 라이브러리인 pthread의 헤더. 유저 thread를 구현 가능.
	5-2. unitsd.h : unix 정규 라이브러리. usleep 사용을 위해 불러옴.
	5-3. stdio.h : printf 함수를 사용하기 위한 라이브러리
	5-4. stdlib.h : malloc 함수를 사용하기 위한 라이브러리
	5-5. sys/time.h : gettimeofday 함수를 사용하기 위한 라이브러리
	5-6. 구조체 philo, flag : 4항 참조
	5-7. 각 소스 파일에서 쓰이는 함수 : 아래 참조
​
6. function   
	6-1. ft_bzero : 구조체 내부를 초기화하기 위한 함수   
	6-2. ft_patoi : 입력으로 들어온 인자들을 검사하기 위한 함수   
	6-3. clean_all : 에러 또는 모든 phase 종료 시, malloc및 mutex를 통해 점유한 자원들을 돌려주기 위한 함수   
	6-4. create_philo   
		6-4-가. 철학자 스레드를 창조하고 모니터링 함수를 시작하기 위한 말 그대로 본 프로그램의 시작을 알리는 함수   
		6-4-나. must_eat = 0, philo_num = 0, philo = 1인 경우, 각각에 대한 예외처리 보장   
		6-4-다. 그 외, 각 철학자 스레드를 생성하고 철학자 스레드 전부 생성한 뒤, 모니터링 함수 호출   
	6-5. print_philo : 몇 ms에 누가 어떤 일을 했는지 출력해주는 함수   
	6-6. print_die : 죽은 철학자가 발생 시, 해당 철학자의 죽음을 출력해주는 함수   
	6-7. chk_over : stop flag 충족 시, 더는 phase를 진행하지 않고 스레드를 종료할 수 있도록 돕는 함수   
	6-8. init_time : time chk를 실시   
	6-9. cur_time : init time을 통해 구한 시간과 시스템이 시작한 시간을 감산하여 쉽게 시간 표기   
	6-10 ~ 6-18. 스레드 작동 방식 참고   
​
7. 현재 쟁점  
	7-1. eating 출력 후에 완전히 print를 막으려면 어떻게 해야될까?
		-> eating 출력을 규제하려면 flag가 더욱 필요. 이 flag는 공유자원으로서 작동하므로 이에 대한 mutex 처리도 	필요. 결국, 문맥 교환의 다발 발생으로 시간 소모가 크고 죽게 될 확률이 높음  
	7-2. 철학자의 포크 경쟁에 따른 데드락을 어떻게 줄이는가?
		-> 식사 순서 보장을 위해 홀과 짝의 시작 시간을 구별
		-> 혹시라도 식사가 겹치는 상황을 방지하기 위해 철학자의 포크 쥐는 법을 홀과 짝에 따라 다르게 함
​
8. 용어   
	8-1. 스레드 : 프로세스 내에서 stack과 register 영역을 별도로 가진 개체. 병렬 처리를 위해 구현한 방식이며 다중 
				프로세스와 달리 코드, 힙, 데이터 영역은 복사하지 않아서 경제적이다.
				단, 운영체제에서 직접 관리하는 커널 스레드와 달리 pthread는 unix에서 user thread를 생성하기에
				운영체제에서는 단일 프로세스 단일 스레드로 보인다. 그렇기에 자원 할당은 pthread 라이브러리에서 구현한 방식으로 이루어지며 본 프로그램에서 별도의 스레드 우선순위를 부여하는 함수는 허가 되지 않기에 문맥 교환의 흐름을 잡기 힘들다    
	8-2. 문맥 교환 : cpu는 코어 당, 하나의 작업을 수행하며 이는 곧 코어 하나가 처리할 수 있는 프로세스는 1개다.  
				cpu가 배분된 코어보다 프로세스가 많은 경우, 운영체제 스케줄링에 의거하여 각각 레지스터에 진행상황을 저장한 채로 코어에 배분된 프로세스를 다른 프로세스로 변경한다. 이 때, 코어가 담당하는 프로세스가 다른 프로세스로 바뀔 경우, 점유하고 있는 메모리도 달라지기에 메모리 변경에 시간이 소요되며 이 때문에 시간 밀림 현상이 발생한다.   
	8-3. 시간 밀림 : 문맥 교환 시, 프로세스와 프로세스를 바꾸는 사이, 메모리 변경에 따른 시간 지연을 말한다. 이는 문맥 교환이 일어날 수록 지속적으로 늘어난다.      
	8-4. 뮤텍스 : 한 프로세스 내에서 멀티 스레드가 공통적으로 접근하는 자원을 공유 자원이라 한다. 공유 자원은 각 스레드의 접근 시기에 따라 값이 다를 수 있기에 온전한 값을 스레드에 넘겨주는 것이 힘들다.   그렇기에 이러한 임계영역 접근, 즉, 공유자원 접근 시, 값을 제대로 읽어줄 수 있도록 현재 읽고 있는 스레드를 제외한 나머지가 진입할 수 없게 자물쇠를 채워야 한다. 이렇게 자물쇠를 채우는 행위를 뮤텍스라 한다. 뮤텍스는 내부적으로 진입이 가능할 때까지, 반복 검사를 실시한다. 그렇기에 뮤텍스를 오래 둘 수록 오히려 검사 횟수가 증가해 연산이 늘어나 부하가 심해진다   